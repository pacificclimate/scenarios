package CICS::Scenario::Explorer;
use strict;

use CICS::Helpers;
use CICS::Scenario::Data;
use CICS::Scenario::Config;
use CICS::Scenario::Cache;
use CICS::Scenario::MainForm;
use CICS::Scenario::Helpers;
use CICS::Scenario::Regions;
use CICS::Scenario::Displayer;

use POSIX qw(floor);

use CGI;
use Apache2::Const qw(OK);
use APR::URI ();
use Apache2::Util;
use Apache2::RequestRec;

use Carp;
$SIG{__WARN__} = \&Carp::cluck;
$SIG{__DIE__} = \&Carp::cluck;

sub handler {
  my($r) = shift();
  my($q) = CGI->new($r->args());
  my($args);
  %{$args} = $q->Vars;

  $r->content_type('text/html');

  # Default important stuff
  if(!defined($args->{lang})) {
    $args->{lang} = 0;
  } else {
    my(@langs) = [ 0, 1 ];
    if(defined($langs[$args->{lang}])) {
      $args->{lang} = $langs[$args->{lang}];
    } else {
      # Defaults
      $args->{lang} = 0;
      $args->{ocean} = 1;
    }
  }
  if(!defined($args->{expt})) {
      if(defined($args->{planners})) {
	  $args->{expt} = 203;
      } else {
	  $args->{expt} = 11;
      }
  }

  my($regions);
  if(defined($args->{planners})) {
      $regions = loadRegions($CICS::Scenario::Config::dat[2]{'planners_regionfile'}, $args->{lang});
  } else {
      $regions = loadRegions($CICS::Scenario::Config::dat[2]{'regionfile'}, $args->{lang});
  }

  my($expt, $exptmulti, $exptdata) = load_gcminfo($CICS::Scenario::Config::dat[2]{gcminfofile}, \@CICS::Scenario::Data::dat);
  my($hash) =
  { expt => $expt,
    exptmulti => $exptmulti,
    exptdata => $exptdata,
    str => \@CICS::Scenario::Data::str,
    dat => \@CICS::Scenario::Data::dat,
    cfg => \@CICS::Scenario::Config::dat,
    lang => $args->{lang},
    post => $args,
    prs => getRegionList($regions, $args->{lang}),
    regions => $regions,
    action => $r->uri
      };

  my($cache) = CICS::Scenario::Cache->new($hash);
  $hash->{cache} = $cache;

  my($mainform) = CICS::Scenario::MainForm->new($hash);
  $hash->{mainform} = $mainform;

  my($inputdata) = $mainform->get_postdata();
  my($descriptions) = $mainform->make_desc_list();
  my($displayer) = CICS::Scenario::Displayer->new($hash);
  my($template_hash) = {};
  my($tslist_pretty) = $hash->{"exptdata"}[$inputdata->{"expt"}]{"display_periods"};
  my($tslist_internal) = $hash->{"exptdata"}[$inputdata->{"expt"}]{"netcdf_periods"};
  $mainform->addElements($template_hash);

  # Used to accumulate the weighted means so we can crunch out
  # 10th, 50th (median) and 90th percentiles.
  my (@accum_wmean);

  # Figure out how the grouping should go
  my($title_t, $list_t, $deschdr, @list, @title, %old);
  {
    # Note about this section: It is coupled to MainForm.pm's make_desc_list
    # The order generated by make_desc_list and the order below must match.
    # Both the GATHER and the MAKEHEADERS block must use the -opposite- order
    # to which the multivars are processed in make_desc_list.
    #
    # To change the order:
    # 1) Rearrange the GATHER block so that the @vars, @vars2, and @descs arrays
    #    contain the data in the correct order
    # 2) Rearrange the items in the 'foreach' statement in the MAKEHEADERS
    #    block to match this
    # 3) Ensure that this is the -opposite- order to that used in
    #    make_desc_list.
    my($i) = 0;
    my(@listvars, @titlevars, @foo);
    my($hdhl) = $hash->{dat}->[$hash->{lang}];
    my($hshl) = $hash->{str}->[$hash->{lang}];
    my($hdd) = $hash->{dat}->[2];

    # BLOCK NAME: GATHER
    # Gather up a coherent list of data items for use in next loop
    my(@vars) = ($hash->{expt}, $hdhl->{timeofyear}, $tslist_pretty, $hdhl->{variable});
    my(@vars2) = ($hash->{exptmulti}, $hdd->{timeofyear}, $tslist_internal, $hdd->{variable});
    my(@descs) = ($hshl->{experiment}, $hshl->{timeofyear}, $hshl->{timeslice}, $hshl->{variable});

    # BLOCK NAME: MAKEHEADERS
    # Run through all potential multivars
    foreach(qw(expt toy ts var)) {
      my($var) = $_;
      $old{$var} = -1;
      # Put up to 2 multivars as the "list" vars -- names shown in the list
      if(is_multivar($vars2[$i]->[$inputdata->{$var}]) && $#listvars < 1) {
	push(@listvars, "<%" . $var . "%>");
	push(@list, [ $var, $i, $vars[$i], $descs[$i] ]);
	push(@foo, $descs[$i]);
      } else {
	# Put the remainder in the "title" vars -- stuff to title things up
	push(@titlevars, "<%" . $var . "%>");
	push(@title, [ $var, $i, $vars[$i], $descs[$i] ]);
      }
      $i++;
    }

    # Reverse the title and list headers' display ordering.
    @title = reverse(@title);
    @list = reverse(@list);

    # Put together the templates
    $list_t = (($#listvars == -1) ? "" : join(" - ", reverse(@listvars)));
    $title_t = join(" - ", reverse(@titlevars));
    $deschdr = (($#listvars == -1) ? "Name" : join(" and<br> ", reverse(@foo)));
  }

  # Output metadata CSV link
  my($desc);
  %{$desc} = %{$inputdata};
  $desc->{plot_type} = TYPE_METADATA_CSV;
  $template_hash->{md_csvlink} = "<a href=\"".$hash->{cfg}->[2]->{wrapper}."?".mkgetstring($desc)."\" alt=\"Metadata CSV\"/>Metadata CSV</a>";

  # Run through the plot descriptions and plot them (up to max)
  my($itemhash, @bits, @diffmaps, @dataitems, @metadataitems, @modeldataitems, @modelmetadataitems, $i, $model);
  my($max) = $hash->{cfg}->[2]->{max_plots};
  push(@modeldataitems, $displayer->make_modeldata_header());
  push(@modelmetadataitems, $displayer->make_modelmetadata_header());
  my(%modelhash);

  # Iterate over every description up to maximum number.
  my($num_descriptions) = ($#{$descriptions} + 1 < $max) ? $#{$descriptions} + 1: $max;

  my($olddesc);
  for($i = 0; $i < $num_descriptions; $i++) {
    my($desc) = $descriptions->[$i];
    
    # Grab in the plot data from genimage
    $displayer->{plotdat} = CICS::Scenario::Helpers::parse_textdata($cache->create_cachefile($desc, TYPE_TEXT));
    
    # Put items into template hash
    foreach(@title, @list) {
      $itemhash->{$_->[0]} = $_->[2]->[$desc->{$_->[0]}];
    }
    
    # Generate title and row desc
    my($title) = parseTemplateString($title_t, $itemhash);
    my($list) = parseTemplateString($list_t, $itemhash);
    
    if(defined($displayer->{plotdat}->{error})) {
      push(@bits, $displayer->make_error_img($desc));
      push(@metadataitems, $displayer->make_metadata_error_row($desc, $list));
      push(@dataitems, $displayer->make_data_error_row($desc, $list));
    } else {
      if($i == 0) {
	$template_hash->{regioncontent} = $displayer->make_region_img($desc);
      }
      push(@bits, $displayer->make_display_img($desc, 0));
      if(($desc->{ts} != $desc->{ts_d} || $desc->{toy} != $desc->{toy_d} || $desc->{expt_d} != $desc->{expt}) && 
	 (is_ts_absolute($desc->{ts}, $desc->{expt}, $hash->{exptdata}) == is_ts_absolute($desc->{ts_d}, $desc->{expt}, $hash->{exptdata}))) {
	push(@diffmaps, $displayer->make_difference_img($desc));
      }
      my($changedmodel, $changed, $rowheader, $exptchanged, $anythingbutexptchanged) = (0, 0, 0, 0, 0);

      # Figure out what vars changed
      my($j) = 0;
      if($#metadataitems == -1) {
	$rowheader = 1;
      }
      foreach(@title, @list) {
	# If something changed
	if($old{$_->[0]} != $desc->{$_->[0]}) {
	  if ($_->[0] eq "expt") {
	    $exptchanged = 1;
	  } else {
	    $anythingbutexptchanged = 1;
	  }
	  if($j <= $#title) {
	    # Title var changed
	    $changed = 1;
	  }
	  my($modelname) = $hash->{exptdata}->[$desc->{$_->[0]}]->{modelname};
	  my($oldmodelname) = $hash->{exptdata}->[$old{$_->[0]}]->{modelname};
	  if($_->[0] eq "expt" && ($old{$_->[0]} == -1 || $modelname ne $oldmodelname) && !defined($modelhash{$modelname})) {
	    # Model changed; output title and model description/data
	    $changedmodel = 1;
	    $model = uc($hash->{exptdata}->[$desc->{$_->[0]}]->{modelname});
	    $modelhash{$modelname} = 1;
	  }
	  $old{$_->[0]} = $desc->{$_->[0]};
	}
	$j++;
      }

      # Add stuff, dependent on variables
      if($changed) {
	push(@metadataitems, $displayer->make_metadata_vars_header($desc, $title));
	push(@dataitems, $displayer->make_data_vars_header($desc, $title));
	if($rowheader) {
	  push(@metadataitems, $displayer->make_metadata_row_header($desc, $deschdr));
	  push(@dataitems, $displayer->make_data_row_header($desc, $deschdr));
	}
      }
      if($changedmodel) {
	push(@modelmetadataitems, $displayer->make_modelmetadata_row($desc, $model));
	push(@modeldataitems, $displayer->make_modeldata_row($desc, $model));
      }

      # Print out percentiles for groups of metadata
      if($desc->{md_pctile}) {
	if ($i != 0) {  # Don't print percentiles on first row!
	  if ($anythingbutexptchanged) { # Only print when there is a change
	    push(@metadataitems, $displayer->get_percentile_rows($olddesc, \@accum_wmean));
	    @accum_wmean = ();
	  }
	}
	push(@accum_wmean, $displayer->{plotdat}->{selwmean});
      }
      push(@metadataitems, $displayer->make_metadata_row($desc, $list));
      push(@dataitems, $displayer->make_data_row($desc, $list));
    }
    $olddesc = $desc;
  }

  # Don't forget to print  metadata percentiles for the very last group of metadata.
  if ($desc->{md_pctile} && $i != 0) {
    push(@metadataitems, $displayer->get_percentile_rows($desc, \@accum_wmean));
  }

  # Set maps as visible
  $template_hash->{mapsclass} = "shown";
  
  # If we've reached the max # of plots, prepare a warning message
  my($too_many_plots) = "";
  if($i == $max) {
    $too_many_plots = "<br/>" . $hash->{str}->[$hash->{lang}]->{too_many_plots};
  }

  # If no region and type of scatter plot is by region, warn user
  {
    my(@scattertsdescs) = @{$mainform->make_scatterts_desc_list()};
    my(@scattervardescs) = @{$mainform->make_scattervar_desc_list()};
    my(@points) = split(/,/, $olddesc->{points});

    # Initialize strings, informing user if average is over entire map
    if($#points == 0) {
      $template_hash->{boxplottscontent} = $template_hash->{scattertscontent} =
	$template_hash->{scattervarcontent} = "<h3>Note: Displaying data point</h3>";
    } elsif($#points < 2) {
      $template_hash->{boxplottscontent} = $template_hash->{scattertscontent} =
	$template_hash->{scattervarcontent} = "<h3>Note: Displaying average over entire map</h3>";
    } else {
      $template_hash->{boxplottscontent} = $template_hash->{scattertscontent} = $template_hash->{scattervarcontent} = "";
    }

    {
      my($i);
      my($max) = $hash->{cfg}->[2]->{max_scatterplots};

      # Plot all the appropriate scatterplots
      for($i = 0; $i <= $#scattertsdescs && $i < $max; $i++) {
	my($desc) = $scattertsdescs[$i];
	$template_hash->{scattertscontent} .= $displayer->make_scatterts_img($desc);
	$template_hash->{boxplottscontent} .= $displayer->make_boxplotts_img($desc);
	if($desc->{sptsdata}) {
	  $template_hash->{scattertstext} .= $displayer->make_scatterts_text($desc);
	}
	if($desc->{spbpdata}) {
	  $template_hash->{boxplottstext} .= $displayer->make_boxplotts_text($desc);
	}
      }
      # If we have more than the max # of plots, warn the person
      if($i == $max) {
	$template_hash->{boxplottscontent} .= $hash->{str}->[$hash->{lang}]->{too_many_plots};
	$template_hash->{scattertscontent} .= $hash->{str}->[$hash->{lang}]->{too_many_plots};
	if($desc->{sptsdata}) {
	  $template_hash->{scattertstext} .= $hash->{str}->[$hash->{lang}]->{too_many_plots};
	  $template_hash->{boxplottstext} .= $hash->{str}->[$hash->{lang}]->{too_many_plots};
	}
      }

      # Plot all the appropriate scatterplots
      for($i = 0; $i <= $#scattervardescs && $i < $max; $i++) {
	my($desc) = $scattervardescs[$i];
	$template_hash->{scattervarcontent} .= $displayer->make_scattervar_img($desc);
	if($desc->{spvardata}) {
	  $template_hash->{scattervartext} .= $displayer->make_scattervar_text($desc);
	}
      }
      # If we have more than the max # of plots, warn the person
      if($i == $max) {
	$template_hash->{scattervarcontent} .= $hash->{str}->[$hash->{lang}]->{too_many_plots};
	if($desc->{spvardata}) {
	  $template_hash->{scattervartext} .= $hash->{str}->[$hash->{lang}]->{too_many_plots};
	}
      }
    }
  }

  $template_hash->{mapcontent} = join("<br/>", @bits) . $too_many_plots;
  if($#diffmaps >= 0) {
    $template_hash->{differencemapcontent} = join("<br/>", @diffmaps) . $too_many_plots;
  } else {
    $template_hash->{differencemapcontent} = "<br/>No valid difference maps available";
  }
  $template_hash->{metadatatable} = "<table cellspacing=\"0\" cellpadding=\"0\" class=\"metadatatable\" width=\"100%\">" . join("", @metadataitems) . "</table>" . $too_many_plots;
  $template_hash->{datatable} = "<table cellspacing=\"0\" cellpadding=\"0\" class=\"datatable\" width=\"100%\">" . join("", @dataitems) . "</table>" . $too_many_plots;
  
  $template_hash->{modelmetadatatable} = "<table cellspacing=\"0\" cellpadding=\"0\" class=\"metadatatable\" width=\"100%\">" . join("", @modelmetadataitems) . "</table>";
  $template_hash->{modeldatatable} = "<table cellspacing=\"0\" cellpadding=\"0\" class=\"datatable\" width=\"100%\">" . join("", @modeldataitems) . "</table>";
  
  $template_hash->{tabno} = $inputdata->{seltab};
  
  # Set up widths
  my($t) = $template_hash;
  $t->{scrnwidth} = $hash->{dat}->[2]->{resolution}->[$inputdata->{res}] - 32;
  $t->{scrnwidth_sidetabs} = $t->{scrnwidth} - 20;
  $t->{mapwidth} = $t->{scrnwidth} - 121;
  $t->{narrowdcol} = floor(0.296 * $t->{scrnwidth});
  $t->{widedcol} = floor(0.40 * $t->{scrnwidth});
  $t->{txtcolumnwidth} = floor(0.14 * $t->{scrnwidth});
  
  # Parse template and output
  if(defined($hash->{post}->{planners})) {
      print parseTemplate($hash->{cfg}->[2]->{planners_template}, $template_hash);
  } else {
      print parseTemplate($hash->{cfg}->[2]->{template}, $template_hash);
  }
  
  return OK;
}

return 1; # modules must return true
